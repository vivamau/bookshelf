<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Chapter 8: Coding</title>
  <link rel="stylesheet"
        type="text/css"
        href="css/style.css" />
  <link rel="stylesheet"
        type="text/css"
        href="css/media.css" />
</head>
<body>
  <div id="part-2-chapter-2" class="element element-bodymatter element-container-single element-type-chapter element-with-heading">
    <div class="heading heading-container-single heading-size-full heading-format-full heading-alignment-flexible heading-without-image">
      <div class="heading-contents">
        <div class="title-subtitle-block title-block-with-element-number">
          <div class="element-number-block">
            <div class="element-number case-upper"><span class="element-number-term">CHAPTER</span> <span class="element-number-number">8</span></div>
          </div>
          <div class="title-block">
            <h1 class="element-title case-upper">CODING</h1>
          </div>
        </div>
      </div>
    </div>
    <div class="text" id="part-2-chapter-2-text">
      <p class="first first-in-chapter first-full-width">Writing code is the core of software engineering. As a software developer, you will likely spend around 50% of your time at work coding – potentially even more! In this chapter, we cover topics on how to get better at this skill. We cover:</p>
      <ol>
        <li><a class="content-external-link" href="part-002-chapter-008.xhtml#subhead-1">Practice coding – a lot!</a></li>
        <li><a class="content-external-link" href="part-002-chapter-008.xhtml#subhead-2">Readable code</a></li>
        <li><a class="content-external-link" href="part-002-chapter-008.xhtml#subhead-3">Writing quality code</a></li>
      </ol>
      <h2 id="subhead-1" class="section-title subhead keep-with-next paragraph-follows case-upper">1. PRACTICE CODING: A LOT!</h2>
      <p class="first first-after-subhead">Being a competent software engineer begins with being a good coder; it’s the foundation of everything discussed in this book. Of course, there are many traits which solid software engineers possess, but coding is an area in which you need to gain strong proficiency. Why? It’s vital to translate your thoughts and ideas into working code as efficiently and seamlessly as possible.</p>
      <p class="subsq">For this, you need to code often, learn a language in depth, and keep solving real-world problems.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Code</span> regularly</b></p>
      <p class="subsq">Developing your coding skills is a bit like sports training. You can read all the resources available on how to code well, and which techniques will make you faster, stronger, and better. But the biggest contributor to your progress is always how much you practice.</p>
      <p class="subsq">This holds for coding, too. Books and online resources can help get you started in expanding your knowledge. But ultimately, you must apply that knowledge by writing code − a lot.</p>
      <p class="subsq">Coding daily is a great habit to pick up because going from learning to code to being “alright” at it, takes a lot of time and effort. Therefore, aim to work on meaningful tasks and problems every day which you solve with code.</p>
      <p class="subsq">Early in your career as a developer, an almost universal expectation most tech companies have, is that you code daily. If you’re not doing this for whatever reason, try to find ways to. This could involve picking up an extra project at work, moving to a team which does a lot of coding, or even working on a side project that sharpens your programming skillset.</p>
      <p class="subsq">You need to code daily to keep growing into a competent software engineer. I know of no substitute for this.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Ask</span> for code reviews</b></p>
      <p class="subsq">Writing code that works is one of the foundations of coding proficiency. Another is writing code others can read and understand, and following common conventions. After you write your code, get feedback on it so you can further improve it. Do code reviews.</p>
      <p class="subsq">Most tech organizations do code reviews; in fact, you cannot push code to production at many places without first going through a code review. But when you’re starting out, you might write a lot of code which doesn’t go into production. For example, you might do prototyping, write a utility or a tool, do experimental projects, or find yourself working alone.</p>
      <p class="subsq">Aim to get feedback on all the code you write, even if code reviews aren’t required. If more experienced people are around, you can ask them for extra feedback to help you grow faster. Most people are happy to spend a little additional time helping junior colleagues.</p>
      <p class="subsq">If getting additional code reviews is hard, you could ask a colleague to pair with you, so you can walk them through your code and ask which areas for improvement they see. And if there’s nobody to work with, try finding someone from outside your team who’s experienced with the technology or the domain, and can give meaningful feedback.</p>
      <p class="subsq">Artificial Intelligence (AI) tools are also useful sources of coding feedback. But be aware that not all AI-generated feedback is always accurate, and these tools will likely not consider additional context, which your teammates do. AI tools are better than nothing, but nothing beats a thorough peer review.</p>
      <p class="subsq"><b>Learn from code reviews. </b>Consider making notes on the feedback you get. If you see repeated comments, consider addressing them. For example, do reviewers regularly point out that your functions do too many things, or that you forget to add tests? Aim to refine how you code by addressing reviewers’ comments, so you don’t get identical feedback repeatedly.</p>
      <p class="subsq">If you don’t understand the reasoning behind a comment, find out by talking to the developer who gave the review.</p>
      <p class="subsq"><b>How do you deal with code reviews that feel harsh? </b>The reality is that there will be code reviews that sting you: their tone will lack empathy, or you will disagree with what a more senior engineer suggests.</p>
      <p class="subsq">Angie Jones is VP of Developer Relations at Block, a Java Champion, and used to be a senior software engineer at Twitter – now renamed to X. She wrote the article, The 10 commandments of navigating code reviews<sup><a id="part-2-chapter-2-endnote-1" class="endnote-source" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-1-text">1</a></sup>, which answers this question in the most thorough way I’ve read. She writes:</p>
      <div class="blockquote-container prose without-attribution within-prose-element">
        <blockquote class="prose without-attribution within-prose-element">
        <p class="first blockquote-content blockquote-content-prose blockquote-position-first">“In my years of developing software, I’ve come up with 10 commandments that I follow to navigate code reviews. They have worked like a charm on every team I’ve ever been a part of, so I hope they work for you.</p>
        <p class="subsq blockquote-content blockquote-content-prose">1. Thou shalt not take it personally. (⋯)</p>
        <p class="subsq blockquote-content blockquote-content-prose blockquote-position-last">I’ve been coding professionally for 15 years and decided long ago not to take code review comments personally. Trust me, I have certainly gotten my fair share of rude or patronizing comments when joining a new team. However, this never lasted long because I learned to navigate code reviews and change the tone of them, no matter what the underlying issue was. Wondering why I am getting rude comments only stresses me out, so I have made the conscious decision to give every reviewer the benefit of the doubt and assume the comment is directed at the code, not me.”</p>
      </blockquote>
      </div>
      <p class="subsq">Read Angie’s <a class="content-external-link" href="https://angiejones.tech/ten-commandments-code-reviews/">10 commandments</a>.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Read</span> as much code as you write</b></p>
      <p class="subsq">While your coding proficiency will grow fastest by writing code, reading code is equally important. If you only focus on writing code, you might develop styles and conventions nobody uses. And later, it may be hard to understand other people’s code. Also, “bad habits” can be difficult to unlearn once embedded in our coding approach.</p>
      <p class="subsq">Often, the easiest way to read code is to get involved early in code reviews across the team or the codebase. Do this even when you’re not an expert in the language, or very familiar with the codebase. Make it a habit to go through each change colleagues make, understand what it does, and make notes on the approaches taken. When something is unclear, talk to the person who wrote the code to learn more.</p>
      <p class="subsq">It’s beneficial to read code written outside of your team or company. If you can access other projects in your workplace, start following code changes and code reviews by teams whose codebases you depend on. Teams and companies often follow conventions specific to their environment.</p>
      <p class="subsq">Reading open-source code is also an excellent way to see other people’s code and get a sense of what’s going on beyond your company. Try to find an actively developed open-source project which works with a similar language as you use. GitHub is the easiest place to do this. Check out a project, familiarize yourself with how it works, and then start following the changes. Try to make sense of what’s happening, which type of code is being written, and the feedback which code reviewers give.</p>
      <p class="subsq">Find a balance between writing and reading code without going overboard on either one.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Code</span> some more</b></p>
      <p class="subsq">You can practice coding in additional ways, aside from doing work projects. Here are some ideas:</p>
      <ul>
        <li><b>Build a side project. </b>A small side project that solves a minor problem for you, your friends, or your family, is a nice way of coding a bit more, and even picking up a new technology stack. A side project gives you the excuse to try new approaches as you wish. Your goal is to write code that works, but you can go crazy and complicate things by using parts of the language you never would, normally.</li>
        <li><b>Complete a tutorial/training with coding exercises.</b> Tutorials and training provide structure, meaning you can just follow along and not think about what to do. Such training is great for going deeper into a specific language or technology. The biggest challenge of tutorials and training is getting the time and motivation to complete them. If your company supports or provides in-person training, take advantage of it. This opportunity is a useful way to dive deeper into a technology.</li>
        <li><b>Do coding challenges</b>. Tackling coding challenges like those on Leetcode, Project Euler, or similar sites, is an opportunity to practice a language which you use, and they can also improve your algorithmic problem-solving skills.</li>
        <li><b>Do regular code katas.</b> This helps to familiarize you with a language, and improve your problem-solving and algorithmic skills. Search online for daily code kata challenges. Code katas should be a short investment of time. Aim to do them regularly – ideally, daily – for a few weeks, until the katas stop being challenging.</li>
      </ul>
      <p class="subsq">Paying for resources can boost your focus. Learning a programming language in depth is time-consuming, and it’s easy to put this task on the back burner when you become “good enough.” There will always be real work to be solved for which you don’t need fancy language features.</p>
      <p class="subsq">A trick I’ve found that helps me to stay focused and not stop midway through the learning process is to be invested in it by paying for the resources I want to study. This provides the knowledge that if I don’t finish it, my money will be wasted. Many free resources are often of similar quality to paid-for ones, but making a financial investment is why I prefer to buy a book, online course, or in-person training. Parting with money gives me the motivation I need to not give up early and lose my investment.</p>
      <h2 id="subhead-2" class="section-title subhead keep-with-next paragraph-follows case-upper">2. READABLE CODE</h2>
      <p class="first first-after-subhead">Readability is one of the most important characteristics of all code. It’s equally important as code that’s correct and does what’s expected.</p>
      <p class="subsq">However, it is harder to verify that code is readable than to verify that code is correct. This is because the correctness of code can be established by using tests: there’s a binary “yes, it is correct,” or “no, it’s incorrect,” answer. There is no equivalent approach to pinpointing hard-to-read code.</p>
      <p class="subsq">Incorrect code cannot hide for long, but unreadable code can go undetected for ages. It sits silently in the codebase until a developer tries to understand what it does while fixing a bug, or adding a new feature. They want to understand what this unreadable piece of code does and whether it needs to be changed.</p>
      <p class="subsq">If code is not readable, an engineer who makes changes later will spend a lot of time on what should be straightforward work. They might misunderstand the code and use it in unintended ways, and then spend multiple iterations on getting the change right. Or they might change the code, unintentionally breaking functionality elsewhere. This is only a minor annoyance if there are automated tests for the functionality. If not, this will mean more problems and more time spent on making the change correctly.</p>
      <p class="subsq">In some cases, a developer might spend so much time trying and failing to understand the code, that they may just completely rewrite it; deleting the original code and writing a new implementation. But not all edge cases may be covered by this rewrite; potentially resulting in more time spent on the rewrite than was on the original code.</p>
      <p class="subsq"><b>The biggest risk of unreadable code is that it starts a low-readability spiral. </b>An engineer making a change spends much time figuring out how the code should work. Instead of making the code more readable, they may make the smallest possible change, resulting in even less readable code. The next person will then spend more time understanding the code and might break the system, or just give up, delete the code, and reinvent the wheel.</p>
      <p class="subsq">Unreadable code is a major contributor to technical debt, which builds up for various reasons, including lack of automated testing, missing processes like continuous integration (CI) or continuous deployment (CD,) and poor onboarding and documentation. Tech debt is a significant contributor to teams slowing down.</p>
      <p class="subsq">This is why code readability and thorough testing are two of the most important principles for pragmatic engineers. Readable, well-tested code makes refactoring, extending, and modifying a codebase as easy as possible. Readable, well-tested code is the foundation of a solid codebase that gives engineers confidence to make changes.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">What is readable code?</span></b></p>
      <p class="subsq">“Readable code” means slightly different things and varies between teams, companies, and programming languages. There are two important judges of how readable code is: yourself and everyone else who reads it.</p>
      <p class="subsq"><b>Readable code begins with code <i>you</i> find easy to read. </b>When finishing coding, take a break to clear your mind. Then, re-read the code as though seeing it for the first time, imagining you know nothing about the changes or why they were made.</p>
      <p class="subsq">Can you follow your code? Do the names of variables and methods help you understand what they do? Are there comments in places where the code isn’t enough? Is the style of the code consistent across the changes?</p>
      <p class="subsq">Think about how you could make the code more readable. Perhaps you see some functions which do too much and are too long. Perhaps you find that renaming a variable makes its purpose clearer. Make changes until you feel the code is as expressive, concise, and presentable as possible.</p>
      <p class="subsq"><b>The test of readable code is simple: can others understand it? </b>Get feedback via code reviews. Ask how clear the code is. Encourage people to ask questions if something doesn’t make sense. Code reviews – especially thorough ones – are the best source of feedback.</p>
      <p class="subsq">Readable code will attract few to no clarifying questions, and reviewers won’t misunderstand it. So, pay attention any time someone misunderstands why you wrote something or asks a clarifying question. Each question and misunderstanding is a hint that the code could be more readable.</p>
      <p class="subsq">A good way to get more feedback about your code’s clarity is to ask someone who is not an expert in the codebase. Ask specifically for feedback about how easy your code is to read. As your colleague will not be an expert, they’ll focus on how much they can follow your code. Most comments they make will be about readability.</p>
      <p class="subsq">If you’re happy with how clear the code is and other developers find it readable, then you’re on the right track. There are many ways to make code more readable and clearer. But before going too deeply into that, focus on the essential of code that’s easily read by yourself and colleagues.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Things to pay</span> attention to</b></p>
      <p class="subsq">You should always write code with two main goals in mind:</p>
      <ol>
        <li>The code should be correct, meaning it produces the expected result when executed.</li>
        <li>Other developers should find it easy to read and understand.</li>
      </ol>
      <p class="subsq">Coding is a social activity. Your code doesn’t exist in a vacuum, implementing a lone task. The code you write will be re-read by many other developers to understand or modify how it works.</p>
      <p class="subsq">The code you write needs to be easy enough for other engineers to maintain. This starts with the code being readable. A few things to pay attention to:</p>
      <ul>
        <li><b>Naming. </b>Use self-explanatory, concise names. Stick to consistent naming approaches in line with the naming used on the codebase.</li>
        <li><b>Well-structured. </b>The codebase is easy to navigate as functions, classes, and modules follow a logical structure. Formatting is consistent across classes and the codebase.</li>
        <li><b>Keep the code simple (KISS)</b>. KISS stands for “Keep it simple, stupid!” The simpler code is, the easier it is to read and understand. With this in mind, aim for small functions and classes that don’t grow too big. Avoid introducing complex coding solutions just for the sake of it, when you could get things done simpler.</li>
        <li><b>Single responsibility.</b> Aim for functions to do just one thing, and for classes to have a main responsibility. A single focus makes it easier to test for correctness, and also for tests to be reusable.</li>
        <li><b>The “DRY” principle:</b> Don’t Repeat Yourself. Avoid copy-pasting code. Instead, if you find the need to reuse, consider refactoring the code so it follows the single responsibility principle.</li>
        <li><b>Comments.</b> There are two schools of thought when it comes to comments; some engineers swear by the code always documenting itself, whereas others see comments as a necessary way of adding context which code cannot convey. Come up with your approach to commenting, keeping in mind the end goal: for someone else to make sense of the code you write. As a rule of thumb, explain the “why” on the code, not the “how” in your comments. This may be context like a business reason for why an edge case was added, or linking to an outage that promoted a seemingly odd code path.</li>
        <li><b>Continuously refactor to maintain readability.</b> Codebases grow. As a simple class gains more responsibility, it expands in size and complexity. Readable codebases stay readable thanks to continuous refactoring. A new complex class might be broken into multiple parts or changed in other ways, in order to stay easy to read.</li>
      </ul>
      <p class="subsq">There are many books and other resources which go into greater depth on what readable code is, and how to make yours clearer. I recommend these:</p>
      <ul>
        <li>“Tidy First?” by Kent Beck</li>
        <li>“The Art of Readable Code” by Dustin Boswell and Trevor Foucher</li>
      </ul>
      <h2 id="subhead-3" class="section-title subhead keep-with-next paragraph-follows case-upper">3. WRITING QUALITY CODE</h2>
      <p class="first first-after-subhead">As a competent software developer, you’ll want to write code that uses the correct amount of abstraction and works reliably enough, accounting for potential error cases. This is, of course, on top of it being readable – which we covered right before this section.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Use</span> the right level of abstractions</b></p>
      <p class="subsq">When you structure your code, you create classes that are abstractions. These classes abstract away implementation details from other parts of the code. For example, you might come across a class called “PaymentsIntent” which implements the following functionality in one file:</p>
      <ol>
        <li>Makes an API request to make a payment</li>
        <li>Takes the JSON response and evaluates whether it’s valid by looking at the signature in the JSON. Transforms it into a PaymentsResponse object</li>
        <li>Returns the PaymentsResponse response</li>
      </ol>
      <p class="subsq">This class doesn’t do much, but you might decide it makes sense to abstract #2 – turning a JSON into a PaymentsResponse object – functionality into its own class. Then, PaymentsIntent would do this:</p>
      <ol>
        <li>Make an API request to make a payment</li>
        <li>Create a new PaymentResponse with the result, and return this object</li>
      </ol>
      <p class="subsq">Why would we abstract away the parsing of the payments response JSON? A few reasons:</p>
      <ul>
        <li>The same functionality from other parts of the code can now be used, without needing to copy logic. This conforms with the Don’t Repeat Yourself (DRY) principle.</li>
        <li>The responsibilities of the classes shrank, and each class has a single responsibility.</li>
        <li>In the future, it will be more straightforward to identify which code should be modified if the payments API responses change, as the parsing functionality lives in one place.</li>
      </ul>
      <p class="subsq">In the book, “A Philosophy of Software Design,” author John Ousterhout describes the benefits of information hiding:</p>
      <div class="blockquote-container prose without-attribution within-prose-element">
        <blockquote class="prose without-attribution within-prose-element">
        <p class="first blockquote-content blockquote-content-prose blockquote-position-first">“Information hiding reduces complexity in two ways. First, it simplifies the interface to a module [or class.] The interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the cognitive load on developers who use the module.</p>
        <p class="subsq blockquote-content blockquote-content-prose blockquote-position-last">Second, information hiding makes it easier to evolve the system. If a piece of information is hidden, there are no dependencies on that information outside the module containing the information, so a design change related to that information will affect only one module.”</p>
      </blockquote>
      </div>
      <p class="subsq">Building a system with the “right” level of abstraction is something you improve at, the more you do it. After all, you don’t want to break up a system into <i>too many</i> small pieces, as excessive numbers of tiny classes add unnecessary cognitive load.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Handle errors,</span> and handle them well</b></p>
      <p class="subsq">In my experience, so many outages lead back to errors being handled incorrectly in some part of the code. As a software developer, when you write code you need to think about how things could go wrong, and spend sufficient time and effort on error handling.</p>
      <p class="subsq"><b>Have a consistent error-handling strategy. </b>What do you do when you come across a condition which could be an error? Do you throw an exception, log the error, do both, or something else?</p>
      <p class="subsq">You should be able to explain how you handle errors; ideally, consistently with how everyone on the team does. Logging errors is a sensible strategy, and you should aim to have a strategy for logging. One is provided in <a class="content-external-link" href="part-005-chapter-023.xhtml">Part V: “Software engineering.”</a></p>
      <p class="subsq"><b>When in doubt, use defensive programming. </b>This assumes inputs from other parts of the code are unreliable and potentially malicious. With this mindset, you tend to question and then validate inputs to a system, a class, or even a function.</p>
      <p class="subsq">Here are a few approaches for defensive programming:</p>
      <ul>
        <li><b>Validate inputs, especially from users.</b> Assume malicious intent or accidentally incorrect information. For example, you expect that a string parameter in a function should be a positive number. But you still validate this to be the case, and throw an error when it’s not.</li>
        <li><b>Expect invalid responses.</b> When invoking a function, don’t assume it will always return a “valid” value. Expect empty responses or odd values. For example, when invoking a function called GetSalaryForEmployee() which returns an integer with the salary for the given employee, it’s good to validate that the returned value is not zero or a negative number and also isn’t a value which is not a number.</li>
        <li><b>Expect malicious inputs</b>. Expect that an attacker might try to deliberately send input that breaks the system. For example, attackers might try to submit strings that could be used for an SQL injection<sup><a id="part-2-chapter-2-endnote-2" class="endnote-source" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-2-text">2</a></sup> attack. Or, on the web, an attacker might try to inject a malicious script using a cross-site scripting (XSS) attack<sup><a id="part-2-chapter-2-endnote-3" class="endnote-source" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-3-text">3</a></sup>.</li>
        <li><b>Expect exceptions and errors.</b> When invoking functions, be prepared that they might throw an exception, or return an error.</li>
      </ul>
      <p class="subsq">There will be times when you don’t need to use defensive programming. For example, when working with a class where all inputs have been validated by design. Also, you might need to worry less about defensive programming when working with strongly typed languages, or languages where functions declare which exceptions they can throw. The more constraints a language has for error handling, the more a compiler can warn of incorrect assumptions.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Be wary of “unknown”</span> states</b></p>
      <p class="subsq">One surprisingly common issue is the mapping of API responses to success or failure codes, and what to do with “unknown” cases. For example, a payment API for requests to make a payment can return responses like “okay,” “not enough funds,” or “API temporarily unavailable.” You need to map these responses in your code to “Success” or “Failure.”</p>
      <p class="subsq">You know the payments API can add or remove responses later, and you want to build a robust enough system to handle future cases when the API might introduce a new code called “Needs User Action.” Here are two common approaches for doing this:</p>
      <p class="subsq"><b>Allowlists. </b>With this approach, you create a list of successful responses (the allowlist) and assume everything else is a failure. So, the allowlist becomes the “OK” response, and everything else is considered a failure.</p>
      <p class="subsq">This approach is more defensive. A problem occurs when there’s a response that’s not strictly a failure, like “Needs User Action.”</p>
      <p class="subsq"><b>Blocklists. </b>With this approach, you create a list of responses considered failures (the block list) and assume everything else is a success. This approach is more risky because the API could introduce new error codes which you’d map as successes.</p>
      <p class="subsq"><b>Handling an “unknown” state can cause unexpected problems. </b>Unfortunately, neither allowlisting or blocklisting works universally. Take an API provider that introduces a type of response code never seen before. The best approach I know for handling such unknown</p>
      <p class="subsq">responses and codes is having a third state (besides “success” and “failure”) that is “unknown,” and raising an error, alert, or something else, to get an engineer to look at it.</p>
      <p class="subsq">Know that whatever decision you make with an unknown state or response could be based on a wrong assumption. Often, the correct way to handle these is to <i>not</i> handle them, but throw an error.</p>
    </div>
    <div class="fewer-than-100-notes">
      <div class="endnotes">
        <div class="endnotes-separator">
        </div>
        <div>
          <div id="part-2-chapter-2-endnote-1-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-1">1</a> </span>https://angiejones.tech/ten-commandments-code-reviews</p>
          </div>
          <div id="part-2-chapter-2-endnote-2-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-2">2</a> </span>https://en.wikipedia.org/wiki/SQL_injection</p>
          </div>
          <div id="part-2-chapter-2-endnote-3-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-002-chapter-008.xhtml#part-2-chapter-2-endnote-3">3</a> </span>https://owasp.org/www-community/attacks/xss</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
