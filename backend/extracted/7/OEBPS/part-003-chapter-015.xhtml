<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Chapter 15: Software Architecture</title>
  <link rel="stylesheet"
        type="text/css"
        href="css/style.css" />
  <link rel="stylesheet"
        type="text/css"
        href="css/media.css" />
</head>
<body>
  <div id="part-3-chapter-5" class="element element-bodymatter element-container-single element-type-chapter element-with-heading">
    <div class="heading heading-container-single heading-size-full heading-format-full heading-alignment-flexible heading-without-image">
      <div class="heading-contents">
        <div class="title-subtitle-block title-block-with-element-number">
          <div class="element-number-block">
            <div class="element-number case-upper"><span class="element-number-term">CHAPTER</span> <span class="element-number-number">15</span></div>
          </div>
          <div class="title-block">
            <h1 class="element-title case-upper">SOFTWARE ARCHITECTURE</h1>
          </div>
        </div>
      </div>
    </div>
    <div class="text" id="part-3-chapter-5-text">
      <p class="first first-in-chapter first-full-width">Software architecture involves design principles and decisions which are usually made early, during the planning phase of a project. These design decisions have an outsized impact on how a system is built, how easy it is to extend and maintain, and how easily new engineers can onboard to the codebase.</p>
      <p class="subsq">The terms “software architecture” and “software design” are interchangeable. I like “architecture,” for its connection to the practice of making physical buildings. Developing a property has two distinct phases: the drawing up of plans (architecting,) and the work of constructing it. These are linked: an original plan can be tweaked as construction progresses, should assumptions made during planning turn out to be less valid.</p>
      <p class="subsq">However, there’s a major difference between architecting buildings and software. The architecting of a property is heavily constrained by laws of physics, which isn’t the case for architecting software. With software, the constraints on what can and cannot be done are much fuzzier. Physical laws govern software engineering much less: skillsets and dynamics on teams, and the constraints of technologies tend to be more important considerations.</p>
      <p class="subsq">Essentially, there is not one approach for doing software design well. But there are approaches that are pretty common across many companies. In this chapter, we cover:</p>
      <ol>
        <li><a class="content-external-link" href="part-003-chapter-015.xhtml#subhead-1">Design documents, RFCs, and architecture documents</a></li>
        <li><a class="content-external-link" href="part-003-chapter-015.xhtml#subhead-2">Prototyping and proof of concept</a></li>
        <li><a class="content-external-link" href="part-003-chapter-015.xhtml#subhead-3">Domain-driven design</a></li>
        <li><a class="content-external-link" href="part-003-chapter-015.xhtml#subhead-4">Software architecture that ships</a></li>
      </ol>
      <h2 id="subhead-1" class="section-title subhead keep-with-next paragraph-follows case-upper">1. DESIGN DOCUMENTS, RFCS AND ARCHITECTURE DOCUMENTS</h2>
      <p class="first first-after-subhead">Many tech companies and startups utilize design documents often referred to as RFCs (Request for Comments,) as part of the planning process, including Uber, Airbnb, Gojek, GitLab, LinkedIn, MongoDB, Shopify, Sourcegraph, Uber, Zalando, and many others<sup><a id="part-3-chapter-5-endnote-1" class="endnote-source" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-1-text">1</a></sup>.</p>
      <p class="subsq">Here, I use “RFC” to refer to design documents, to emphasize that they are a way to gather feedback which improves a design. RFCs are created by engineers for non-trivial projects before they start the meaningful work. There are usually no hard rules; they exist to share context and the suggested approach, tradeoffs, and to invite feedback.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">The goal</span> of an RFC</b></p>
      <p class="subsq">As mentioned, the overall objective of writing and distributing an RFC is to shorten the time it takes to complete a project, by getting key feedback early. It’s up to engineers working on the project to decide how an RFC fits into their workflow. Here are a few approaches:</p>
      <ul>
        <li><b>Prototype, then RFC, then build. </b>This is typical for projects with many unknowns – like building on a new framework – which can be discovered by prototyping. The RFC shares a partially completed plan, perhaps with gaps. The team gets feedback, and then builds.</li>
        <li><b>RFC, wait for feedback, then build.</b> For projects with lots of dependencies or teams that are dependent on what’s being built, progress may ultimately be faster if feedback from all stakeholders is gathered first.</li>
        <li><b>RFC, then build while awaiting feedback.</b> For projects of some complexity about which there are unlikely to be many questions, it’s pragmatic to start building when the RFC is distributed. The team can easily incorporate feedback, and not lose much time if changes are needed.</li>
        <li><b>Build, then RFC.</b> Engineers build what they need to and then write an RFC which documents decisions taken. This may be because the project was more complex than planned, or to comply with internal rules on RFCs. This approach can get awkward, as the RFC is seen as a “tick box” exercise, and the team doesn’t welcome actionable feedback. But the document is useful for archival purposes, and getting feedback at this point is still better than later after people move on to new projects.<i> In my experience, this approach is fairly common.</i></li>
      </ul>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Benefits</span></b></p>
      <p class="subsq">Writing an RFC and distributing it for feedback has some major benefits:</p>
      <ol>
        <li><b>You clarify your thinking. </b>How many times have you rushed into coding up a solution, only to realize halfway through that you’re on the wrong track? If only you’d clarified what you’re trying to do, then this could have been avoided. A design document <b>forces you to explain your thinking in a way that makes sense to you and others.</b></li>
        <li><b>Get important feedback, faster.</b> If you just go and code up a solution and present it to your team, you’ll often get feedback which creates extra work. For example, a teammate might point out missing edge cases, or the product manager could say the wrong use case is being solved for. A document via which people can give feedback before coding starts, helps minimize misunderstandings and additional work.</li>
        <li><b>It scales your ideas.</b> If you don’t create a design document, the only way for another engineer to understand your thinking is by talking with you, directly. If five engineers want to understand your approach to building the system, then all five need to grab time with you. By writing the plan down instead, they can read it and ping you with questions.</li>
        <li><b>It promotes a writing culture. </b>If teammates see value in your design document, they’re more likely to do the same for their projects. This is a win for everyone, including you, as sharing documents usually leads to better feedback, quicker.</li>
      </ol>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Reviewing</span> RFCs</b></p>
      <p class="subsq">Reviewing RFCs is obviously key to getting the feedback they contain. The most common ways to get feedback are:</p>
      <ul>
        <li><b>Asynchronous feedback:</b> via comments in the document. Google, GitHub, and Uber gather feedback this way.</li>
        <li><b>Synchronous feedback: </b>organize a meeting to discuss an RFC in depth. Amazon, the online retail giant, prefers this type of process.</li>
        <li><b>Hybrid:</b> a document is distributed to gather feedback asynchronously. A meeting is called if the project’s complexity warrants it, or there are many comments.</li>
      </ul>
      <p class="subsq">The best format depends on the project. You need a different approach for a project which impacts twenty teams who all give feedback, than when you’re building a service that only your team and a single partner team will use.</p>
      <p class="subsq">Don’t forget the <i>true</i> goal of the RFC process. It’s to reduce the time it takes to ship a project, by getting feedback early. Ask yourself which approach saves the most time.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Architecture documents</span></b></p>
      <p class="subsq">Architecture documents differ slightly from RFCs, in that they are written to record decisions made, with little intent for feedback – which is unlike RFCs. Architecture documents come in a few popular formats, and each company tends to have a favorite:</p>
      <ul>
        <li><b>ADR</b><sup><a id="part-3-chapter-5-endnote-2" class="endnote-source" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-2-text">2</a></sup><b> </b>(Architecture Design Record) is probably the most popular format due to being created for use with Git as Markdown files, and its simple structure.</li>
        <li><b>C4 model</b><sup><a id="part-3-chapter-5-endnote-3" class="endnote-source" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-3-text">3</a></sup><b> </b>is a more involved, diagramming software architecture, defining four diagram levels for use: context, containers, components, and code. It was created by independent consultant and author, Simon Brown.</li>
        <li><b>Arc42</b><sup><a id="part-3-chapter-5-endnote-4" class="endnote-source" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-4-text">4</a></sup> is an approach that comes with an opinionated template of 12 sections, including “Context and scope,” “Solution strategy,” “Building block view,” and “Cross-cutting concepts.”</li>
      </ul>
      <h2 id="subhead-2" class="section-title subhead keep-with-next paragraph-follows case-upper">2. PROTOTYPING AND PROOF OF CONCEPT</h2>
      <p class="first first-after-subhead">How do you build a complex system that works as expected? Thorough planning is one approach. An alternative – often underrated – is to not start with planning. Instead, start by showing how it could work, and build a quick-and-dirty prototype for demonstration purposes.</p>
      <p class="subsq">The issue with complex projects is that there are unknowns, and the planning stage involves debate about these unknowns. Building a prototype can address some unknowns and show an approach could work well enough.</p>
      <p class="subsq">I recall being part of a project to architect a new, complex payments system, which would replace two existing payments systems. It involved around 10 engineering teams. Initially, all teams planned their own approaches. For two months, hundreds of pages of RFCs were produced and circulated. But the project didn’t achieve a consensus about how to proceed.</p>
      <p class="subsq">Then the group changed tack and brought one representative from each team together, and this new team spent two weeks prototyping a barebones approach. There were no planning documents and no comments were sought; it was just people in one location writing code and demonstrating ideas through prototyping.</p>
      <p class="subsq">Within two weeks, the group built a prototype and addressed many sources of conflicts and unknowns. This prototype was thrown away later, but served as the scaffolding for different systems’ ownership, and how they talk with each other.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Prototyping</span> for exploration</b></p>
      <p class="subsq">Many software engineers whom I consider great software “architects” build throwaway prototypes to prove a point and showcase their ideas. After all, it’s a lot more productive to reason about concrete code than abstract ideas.</p>
      <p class="subsq">When there are many unknowns or moving parts, use prototyping as an exploration tool. It’s a fantastic fit for problems about which there isn’t enough information to make a plan with high confidence. For example, if you need to integrate with a third-party API but aren’t sure how, build a throwaway prototype that does third-party API calls and provides a suggestion for how it could work.</p>
      <p class="subsq">I’d argue that if you’re <i>unable</i> to prototype architecture ideas, then you’re no longer hands-on with development, or an idea is over-complicated. Otherwise, you could demonstrate how it works with a prototype!</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Build</span> with the intent to throw it away</b></p>
      <p class="subsq">Build <i>throwaway</i> proof of concepts and make it clear they’re not for production. The point of prototyping is to prove something could work, and to then start building it properly, after validation. You’ll learn a lot by building a proof of concept to show people, and have productive conversations about something concrete and specific.</p>
      <p class="subsq">You can move faster by being clear that what you build is throwaway, so there’s no need for code reviews, automated tests, or code that can be maintained later. Seriously, you don’t need any of these things because it’s throwaway!</p>
      <p class="subsq">The danger with any proof of concept is that someone higher up, like a product manager, says it looks good and to ship it. But it’s a prototype which was hacked together, and none of the practices for production code have been applied. Shipping in this state would be a bad idea! In this case, stand your ground and refuse to ship a prototype. Build a proper version from scratch, instead. This should not be so difficult with a working prototype.</p>
      <p class="subsq">If there’s too much pressure to ship prototypes, use the trick of purposely building the prototype on top of non-production technologies. For example, if your team uses Go on the backend, write the prototype in Node.js which is obviously only used for prototyping, and won’t be shipped.</p>
      <p class="subsq">To develop better architecture approaches, use prototyping to build proofs of concept as a tool. The more you do this, the more productive you’ll become and the better the architecture you build will be.</p>
      <h2 id="subhead-3" class="section-title subhead keep-with-next paragraph-follows case-upper">3. DOMAIN-DRIVEN DESIGN</h2>
      <p class="first first-after-subhead">Domain-driven design (DDD) involves starting by creating a business domain model to understand how the business domain works. For example, when building a payments system, start by understanding the payments domain, business rules, and context of the payments domain.</p>
      <p class="subsq">The term “domain-driven design” was coined by Eric Evans in his book, “Domain-Driven Design: Tackling Complexity in the Heart of Software.” Its components are:</p>
      <ul>
        <li><b>A standard vocabulary. </b>The first step is to ensure everyone involved in the design speaks the same language. DDD calls this the ‘ubiquitous language.’ To develop this shared vocabulary, sit down with business domain experts and define the terms and jargon to be used. This might seem a simple task, but software engineers and payment compliance experts may define things very differently; even a term as seemingly clear as “making a payment.”</li>
        <li><b>Context.</b> Break up complex areas into smaller parts, which DDD refers to as ‘bounded contexts.’ Each of these contexts has its own standard vocabulary. For example, when designing a payment system, contexts could be Onboarding, Paying in, Paying Out, and Settlement. Each context can be modeled independently and broken down further.</li>
        <li><b>Entities.</b> An entity is something defined primarily by its identity, which has a life span. Many named things, like the parts of a system, people, and locations, tend to be entities. For example, an accounting entry would be an entity in a payments system.</li>
        <li><b>Value objects</b> describe entities and are immutable, meaning they don’t change. For example, the currency of an accounting entry is a value object.</li>
        <li><b>Aggregates</b> are clusters of entities treated as a single unit.</li>
        <li><b>Domain events</b> are things that happen which other parts of the domain should be aware of and may react to. Domain events help to make triggers – and reactions to triggers – more explicit. For example, when a payment comes into a payment system, the account balance increases by the sum of the payment. However, when introducing a domain event like a PaymentMadeEvent, this formerly implicit logic becomes explicit: the Account now reacts to PaymentMadeEvents, not monitoring of Payment objects that arrive.</li>
      </ul>
      <p class="subsq">The biggest benefit I’ve seen of applying DDD principles to a software engineering project is that it forces software engineers to understand the business context. You need to talk with business folks and let them describe how their world works. Thanks to shared vocabulary (see above,) the software you build will resemble the “real world” more closely.</p>
      <p class="subsq">A few benefits of DDD approaches:</p>
      <ul>
        <li><b>Fewer misunderstandings between engineers and the business</b>. So many software projects are late because software engineers build something different from what the business expects. With DDD, there’s plenty of communication with business stakeholders from the start, so the chance of misunderstandings greatly reduces.</li>
        <li><b>A better handle on business complexity. </b>Business rules can be surprisingly complex, and DDD helps capture this, and tame it using Bounded Contexts.</li>
        <li><b>More readable code.</b> Thanks to a well-defined, shared vocabulary, the code is clearer. Class and variable names are more consistent and easier to understand. The code will be cleaner, as a whole.</li>
        <li><b>Better maintainability.</b> Thanks to easier-to-understand code and a defined vocabulary.</li>
        <li><b>Easier to extend and scale. </b>When new business use cases need to be added, this extension can be first inserted into the existing domain model. Once the logical extensions are made, implementing the change at code level is easier. Scaling a codebase by adding a large number of new business use cases is much easier and less messy.</li>
      </ul>
      <p class="subsq">To learn more about applying DDD, I recommend these books:</p>
      <ul>
        <li>Learning Domain-Driven Design by Vlad Khononov (2021)</li>
        <li>Domain-Driven Design<sup><a id="part-3-chapter-5-endnote-5" class="endnote-source" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-5-text">5</a></sup> by Eric Evans (2003)</li>
      </ul>
      <h2 id="subhead-4" class="section-title subhead keep-with-next paragraph-follows case-upper">4. SOFTWARE ARCHITECTURE THAT SHIPS</h2>
      <p class="first first-after-subhead">I’ve talked with plenty of experienced software engineers who were frustrated that their architecture ideas for improving systems were hard to ship, due to pushback received while circulating their idea. So, how can you get helpful ideas shipped to production?</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Verbalize</span> the business goal</b></p>
      <p class="subsq">Take a step back and consider what the business goal of this change is. How will it help your product or company? Which business metrics would it improve, like revenue, costs, user churn, developer productivity, or other things the business cares about? Once you have an idea of the business impact, it should be easy enough to make a case for prioritizing this change.</p>
      <p class="subsq">If the business impact is much smaller than that of ongoing projects, ask if it’s pragmatic to spend time working on a relatively low-impact project. Of course, it’s sensible to work on projects with smaller business impacts if they help the engineering team. But when there are higher-impact projects, it’s reasonable to do lower-import work on the side, or to fit it around the other projects.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Get buy-in</span> from stakeholders</b></p>
      <p class="subsq">For architecture changes, you often need buy-in from other teams, senior-and-above engineers, and sometimes, from business colleagues. For this, you’ll need to present your idea and win the support of key people. A few ways to do this:</p>
      <ul>
        <li>Meet the key people and describe your approach. <i>This is pretty time-consuming, and it can be hard to reference specifics later.</i></li>
        <li>Write a proposal, send it around, gather comments, and get people to sign off on your idea. <i>This approach scales better, and makes decisions less ambiguous.</i></li>
        <li>Start by writing things down, and end by talking to key people who are “on the fence” about your idea. Then, update your proposal with modifications after those conversations.<i> This is a hybrid approach and should work in the majority of cases for getting support.</i></li>
      </ul>
      <p class="subsq">An underrated way to get key people to agree to a written proposal is to seek their input <i>before</i> you write the proposal. So, take time to present your idea to a select few stakeholders. Whiteboard your ideas, ask for feedback, and incorporate it into your document. Then let those people know their input was taken into consideration, and they will almost certainly support your approach. Early support could make it easier to win over the rest of the group, too.</p>
      <p class="subsq">As you seek buy-in, don’t forget the goal of your work is to support the business, but you may get feedback from people who think the work will not do this. Don’t dismiss this feedback: there are times when not doing something is the right choice for the business. It’s not personal.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Break out</span> from decision paralysis</b></p>
      <p class="subsq">There are times when architecture decisions get stuck because a group is divided on which path to take. Here are some ways to break the deadlock:</p>
      <ul>
        <li><b>Specify capability requirements.</b> These dictate the outcome, not the implementation. They can be system-level constraints you need to adhere to, like expected latency, or acceptable consistency requirements. They can also be constraints on the UX side, such as response times of no more than 500 ms, or business constraints such as double charging is unacceptable. Once outlined, you can inspect suggested solutions through the lens of capability requirements. Outline these before coming up with solutions, and remove solutions bias, which means jumping into ”solution mode” before you understand the problem.</li>
        <li><b>Appoint a decision-maker before the discussion.</b> Agree on a decision maker in case of a conflict. Doing this in advance of a discussion is best, because introducing a decision-maker during a conflict tends to create friction, by raising the question of how neutral they are. For example, if a participant pulls in their own manager to be the decision maker, that person will likely support their team member.</li>
        <li><b>Who will do the coding, is the tie-breaker.</b> The simplest and fairest way is to leave the decision to the person who does the coding. After all, they will also have to take on the maintenance burden of the solution.</li>
        <li><b>Prototype.</b> When things are stalling, go ahead and build a prototype of your idea. This is guaranteed to get things moving and people will talk about the prototype, not the deadlock.</li>
        <li><b>Get sponsorship from your product counterpart.</b> Product managers have a vested interest in building the right solutions for the business, in both the short-term, and also for long-term maintainability costs. Product sponsorship is a very effective way to avoid deadlocks. But most software engineers don’t utilize it nearly enough!</li>
      </ul>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Roll out changes</span> properly</b></p>
      <p class="subsq">Once the changes are built, devote enough time to a proper rollout, because there’s more chance something could go wrong if you’re not meticulous about the rollout.</p>
      <ul>
        <li><b>Quantify what the rollout means.</b> Find metrics that indicate if the new architecture works as expected. This could be tracking usage of the “old” system versus the new, performance metrics, business metrics, and so on.</li>
        <li><b>Have a rollout plan.</b> Define the phases of the rollout. How will you validate that a rollout phase is “healthy,” and the next phase can start?</li>
        <li><b>Define the right ‘time to bake.’</b> When shipping major changes, take time to validate that all parts of the system work as expected. Use generous enough time frames for the new system to “bake” in production, before declaring the project a success. And be sure to measure key system health metrics during the baking phase.</li>
        <li><b>Have a rollback plan.</b> How can changes be undone if something goes wrong during rollout? It’s more challenging if the rollout includes changes to data, or the data schema.</li>
        <li><b>Do a ‘pre-mortem’ exercise.</b> If a rollout fails, what could the causes be? Map out possible scenarios, then figure out how to detect such failures, and prevent them from happening.</li>
      </ul>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">No decision is</span> final in software engineering</b></p>
      <p class="subsq">There’s no doubt you will have disputes in which the sensible approach is to concede, in favor of an approach you don’t fully support. This outcome may not be as bad as it sounds. No decisions are final when it comes to software!</p>
      <p class="subsq">Almost every decision can be reversed later, including technology changes, architecture approaches, and business rules added. The cost of reversing a decision varies and some are very expensive to reverse. So long as the decision is pretty easy to reverse, then going with one choice beats being stuck in a deadlock!</p>
      <p class="subsq">Architecture changes with rollback plans are pretty easy to reverse, should they not work as expected. For changes involving a migration, there should be a way to migrate back to the original state.</p>
      <p class="subsq">When you roll back a decision, capture the learnings on why the approach didn’t work and share them, typically as a document, distributed to relevant people. It could be sent via email, shared over chat, or presented in a meeting.</p>
      <p class="subsq">Even if a team decides on a given architectural approach, then builds and rolls it out, there’s nothing stopping someone from introducing a different approach with new upsides and downsides, later. After all, this is exactly how software systems evolve to keep up with ever-changing business requirements and the real world.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Reflect</span> on your architecture decisions</b></p>
      <p class="subsq">When a project is shipped, it’s common for the team to hold a retrospective to discuss what went well, what could have been better, and what will be different next time.</p>
      <p class="subsq">When was the last time you reflected on your architecture decisions? One issue is that new architecture needs time to “bake” and prove itself. Also, to get a sense of how well an approach works, you need to be hands-on enough to observe how the architecture holds up when engineers maintain and extend it.</p>
      <p class="subsq">You need to give your newly shipped architecture enough time to observe how decisions play out across a longer timeframe. And then, you need motivation to gather feedback from users.</p>
      <p class="subsq">This isn’t always easy. Here are some sources of motivation for making the effort to gather feedback on how well the system (and therefore the architecture) actually performs:</p>
      <ul>
        <li><b>Share your learnings.</b> Commit to sharing your learnings about the architecture.</li>
        <li><b>Performance reviews/promotions.</b> How will your management chain know how useful your work on a given system was? Gathering feedback could help your work gain more recognition.</li>
        <li><b>Help others with your learnings.</b> You might mentor engineers who are looking to design similar systems as you. Go back and get feedback to reflect on how your design decisions worked out – and what could’ve been better.</li>
      </ul>
      <p class="subsq">When gathering feedback on your work, it can be tempting to only focus on the positives. It’s great to hear your work is well received, but this doesn’t help you grow as a software engineer nearly as much as a valid critique does. As you collect feedback, find out where your architecture decisions didn’t work as well as expected, and build on these very valuable lessons. Too few engineers do this proactively!</p>
    </div>
    <div class="fewer-than-100-notes">
      <div class="endnotes">
        <div class="endnotes-separator">
        </div>
        <div>
          <div id="part-3-chapter-5-endnote-1-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-1">1</a> </span><a class="content-external-link text-is-url" href="https://blog.pragmaticengineer.com/rfcs-and-design-docs">https://blog.pragmaticengineer.com/rfcs-and-design-docs</a></p>
          </div>
          <div id="part-3-chapter-5-endnote-2-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-2">2</a> </span><a class="content-external-link text-is-url" href="https://adr.github.io">adr.github.io</a></p>
          </div>
          <div id="part-3-chapter-5-endnote-3-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-3">3</a> </span><a class="content-external-link text-is-url" href="https://c4model.com">c4model.com</a></p>
          </div>
          <div id="part-3-chapter-5-endnote-4-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-4">4</a> </span><a class="content-external-link text-is-url" href="https://arc42.org">arc42.org</a></p>
          </div>
          <div id="part-3-chapter-5-endnote-5-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-015.xhtml#part-3-chapter-5-endnote-5">5</a> </span><a class="content-external-link text-is-url" href="https://www.domainlanguage.com/ddd">www.domainlanguage.com/ddd</a></p>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
