<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Chapter 13: Software Engineering</title>
  <link rel="stylesheet"
        type="text/css"
        href="css/style.css" />
  <link rel="stylesheet"
        type="text/css"
        href="css/media.css" />
</head>
<body>
  <div id="part-3-chapter-3" class="element element-bodymatter element-container-single element-type-chapter element-with-heading">
    <div class="heading heading-container-single heading-size-full heading-format-full heading-alignment-flexible heading-without-image">
      <div class="heading-contents">
        <div class="title-subtitle-block title-block-with-element-number">
          <div class="element-number-block">
            <div class="element-number case-upper"><span class="element-number-term">CHAPTER</span> <span class="element-number-number">13</span></div>
          </div>
          <div class="title-block">
            <h1 class="element-title case-upper">SOFTWARE ENGINEERING</h1>
          </div>
        </div>
      </div>
    </div>
    <div class="text" id="part-3-chapter-3-text">
      <p class="first first-in-chapter first-full-width">Software engineering starts with coding and ends with practices which guarantee the long-term maintainability and extensibility of the systems you build. In this chapter, we cover areas in which well-rounded, senior engineers are competent:</p>
      <ol>
        <li><a class="content-external-link" href="part-003-chapter-013.xhtml#subhead-1">Languages, platforms, and domains</a></li>
        <li><a class="content-external-link" href="part-003-chapter-013.xhtml#subhead-2">Debugging</a></li>
        <li><a class="content-external-link" href="part-003-chapter-013.xhtml#subhead-3">Tech debt</a></li>
        <li><a class="content-external-link" href="part-003-chapter-013.xhtml#subhead-4">Documentation</a></li>
        <li><a class="content-external-link" href="part-003-chapter-013.xhtml#subhead-5">Scaling best practices across a team</a></li>
      </ol>
      <h2 id="subhead-1" class="section-title subhead keep-with-next paragraph-follows case-upper">1. LANGUAGES, PLATFORMS, AND DOMAINS</h2>
      <p class="first first-after-subhead">It’s expected that a well-rounded senior engineer has a solid grasp of a few programming languages and a few platforms – platforms like frontend, backend, iOS, Android, native desktop, embedded, and so on –, and mastery of at least one. We cover more on how to master a language in <a class="content-external-link" href="part-002-chapter-009.xhtml">Part II: ”Software Development.”</a></p>
      <p class="subsq">However, an effective engineer doesn’t stop at being proficient in a few technologies; they continue to broaden their knowledge of frameworks, languages, and platforms.</p>
      <p class="subsq"><b>When you know a programming language, learning another one is much easier. </b>This is because most languages are pretty similar – at least on the surface. For example, if you know JavaScript, then learning TypeScript begins easily enough. Likewise, knowing Swift means you can understand a lot of Java, Kotlin, or C#, just by reading them.</p>
      <p class="subsq">Of course, each language has its own syntax, idiosyncrasies, strengths, and weaknesses. You discover all these details by using the language and comparing it to others you already know, well enough.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Learn an imperative,</span> a declarative, and a functional language in depth</b></p>
      <p class="subsq">There are three distinct types of programming languages:</p>
      <ol>
        <li><b>Imperative: </b>the most common type of programming language, wherein the computer is given step-by-step instructions on what to do, as a set of commands. For example: “If X, then do this. Or else, do that.” C, C++, Go, Java, JavaScript, Swift, PHP, Python, Ruby, Rust, TypeScript, and most object-oriented languages are imperatives.</li>
        <li><b>Declarative programming</b> specifies the expected outcome of the program but doesn’t give instructions on how to achieve this. SQL, HTML, and Prolog languages are examples.</li>
        <li><b>Functional </b>languages are a subset of declarative languages that are distinct enough to merit their own category. These treat functions as first-class, meaning functions can be passed as arguments to other functions, or returned as values. Examples include Haskell, Lisp, Erlang, Elixir, and F#. Functional languages tend to provide immutable states and pure functions with no side effects.</li>
      </ol>
      <p class="subsq">Your first – or even second – programming language is most likely an imperative one. Learning additional imperative languages is useful, but picking a different type of language will help you grow more as a professional.</p>
      <p class="subsq">Imperative, declarative, and functional languages each require different ways of thinking. It can be challenging to switch from an imperative language to a functional or declarative one, but you expand your understanding and “toolkit” by doing so.</p>
      <p class="subsq">For example, functional programming is widely applied within imperative languages, because following a functional model guarantees an immutable state. A good case is the Reactive programming pattern<sup><a id="part-3-chapter-3-endnote-1" class="endnote-source" href="part-003-chapter-013.xhtml#part-3-chapter-3-endnote-1-text">1</a></sup>, which takes functional programming ideas and offers a more functional pattern to languages like Java (RxJava), Swift (RxSwift), C# (Rx.NET), Scala (RxScala) and others<sup><a id="part-3-chapter-3-endnote-2" class="endnote-source" href="part-003-chapter-013.xhtml#part-3-chapter-3-endnote-2-text">2</a></sup>.</p>
      <p class="subsq">After you master a language from each category, you will have little trouble picking up more languages. This is because there are more fundamental differences between an imperative and a functional language like Go and Elixir, than between two imperative or two functional languages, such as Go and Ruby, or Elixir and Haskell.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Get</span> familiar with different platforms</b></p>
      <p class="subsq">It’s common for a software engineer to specialize in a platform, like:</p>
      <ul>
        <li>Backend</li>
        <li>Frontend</li>
        <li>Mobile</li>
        <li>Embedded platforms</li>
      </ul>
      <p class="subsq">When your team is building a new feature or solving a problem, there’s a good chance work will take place across platforms. For example, shipping a new payment flow will surely mean changes on the backend, the frontend, and perhaps even the mobile side. Debugging in the mobile app will mean investigating whether the issue derives from the mobile business logic, the backend, or perhaps at the intersection of backend APIs and the mobile business logic parsing the API response.</p>
      <p class="subsq">If you have no idea what happens on neighboring stacks, you’ll have trouble debugging more complex, full-stack issues, and leading projects to build and ship full-stack features.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Become more</span> full stack</b></p>
      <p class="subsq">“Full stack engineering” is increasingly a baseline expectation of senior engineers across the tech industry. This is because product folks and business stakeholders don’t really care about the distinction between embedded, backend, and frontend/web. From their point of view, the distinction is an engineering decision.</p>
      <p class="subsq">A well-rounded senior engineer can take any problem and figure out how to break it down between different platforms. To do this, expertise in your domain is needed, along with enough competence in other domains.</p>
      <p class="subsq">So, how do you build this understanding? There are plenty of approaches:</p>
      <ul>
        <li><b>Get access to other platforms’ codebases. </b>For example, if the team you work on owns mobile, web, and backend codebases, then get access to those which aren’t your “primary” platforms. If you’re a backend engineer, check out the web and mobile codebases and set them up for compiling, running tests, and deploying them locally on your machine.</li>
        <li><b>Read code reviews of code written on other platforms.</b> Follow along with code reviews, by reviewing those on other platforms, or by asking to be added as a non-blocking reviewer. Reading code is much easier than writing it, and most code changes are related to business logic, so you should have little trouble understanding the intentions of changes. You might even be able to spot business logic issues or missing business logic test cases!</li>
        <li><b>Volunteer for small tasks on the other platform.</b> The best way to get more familiar with another platform is to work with it. Pick up a non-urgent, unimportant task you can complete at your own pace. Ask advice from other engineers on the team.</li>
        <li><b>Pair with an engineer working on another stack.</b> Pair programming is an efficient way to pick up a new stack. Ask to pair with someone who is more experienced on the stack you’d like to pick up; you’ll speed up the learning process. You could start by shadowing this person – and as you become more hands-on, ask to lead the session and for the other person to give feedback on your approach.</li>
        <li><b>Do an “exchange month” of working on another platform.</b> An even better way to learn more intensively is to switch platforms for a period of time. This could be a few weeks, or months. The downside is that your velocity will drop in the short term, as you’ll be learning the basics of another platform. However, in the mid to long term, your velocity will increase as you’ll have the expertise and tools to unblock yourself.</li>
      </ul>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">AI helpers can make</span> the transition quicker</b></p>
      <p class="subsq">AI helpers can aid the transition between languages and platforms. With tools like GitHub Copilot, ChatGPT, Sourcegraph Cody, and other AI assistants, it’s much easier to pick up new programming languages or switch platforms. These assistants can do things, like:</p>
      <ul>
        <li>Translate a piece of code from one language to another</li>
        <li>Summarize how functions and variables are declared in a language</li>
        <li>Summarize differences between two languages</li>
      </ul>
      <p class="subsq">Keep in mind that many AI assistants suffer from hallucination: they sometimes make up things that aren’t true. Therefore, it’s necessary to verify their output. But for the purpose of getting familiar with a new language or platform, AI assistants are helpful and can speed up the learning process.</p>
      <h2 id="subhead-2" class="section-title subhead keep-with-next paragraph-follows case-upper">2. DEBUGGING</h2>
      <p class="first first-after-subhead">The difference between a senior and a non-senior engineer is pretty clear in debugging and tracking down difficult bugs. More experienced engineers tend to debug faster and pinpoint the root causes of more challenging problems – seemingly with ease. They also have a better sense of where the issue might come from, and where to get started in debugging and resolving it. How do they do this?</p>
      <p class="subsq">Part of it is practice and expertise. The longer you write code, the more often you come across unexpected edge cases and bugs, and so you start to build a “toolkit” of the potential root causes of problems.</p>
      <p class="subsq">Over time, you also expand your debugging toolkit. In <a class="content-external-link" href="part-002-chapter-009.xhtml">Part II: “Software development,”</a> we touch on how to get better at debugging, covering:</p>
      <ul>
        <li>Get to know your debugging tools</li>
        <li>Know how to debug without tools</li>
        <li>Familiarize yourself with advanced debugging tools</li>
      </ul>
      <p class="subsq">The ability to debug efficiently tends to set experienced and less experienced engineers apart. Below are more approaches for improving at debugging.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Know</span> which dashboards and logging systems to look at</b></p>
      <p class="subsq">Especially at larger tech companies, your ability to debug production issues is heavily dependent on knowing where to find production logs and production metrics, and how to query these metrics. Even so, it usually takes months for senior engineers to appreciate the importance of locating these systems.</p>
      <p class="subsq">Finding the right dashboards and logging portals can be especially challenging at companies where teams own many services, and each uses different ways of logging things, recording information in various systems, or using different logging formats.</p>
      <p class="subsq">Upon joining a company, make it a priority to learn where the production logs are stored, and where to find systems’ health dashboards. These might be living in systems like Datadog, Sentry, Splunk, New Relic, or Sumo Logic. Or within in-house systems built on top of the likes of Prometheus, Clickhouse, Grafana, or other custom solutions. And they might be in a mix of places. Figure out where they are, get access, and learn how to query them. Do this for systems your team owns, and also related systems which you interact with.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Make debugging easier</span> for others</b></p>
      <p class="subsq">As a senior engineer, you should know which dashboards and logging systems to look at. But if they are not in place, then you’re in a position to put them in place and make them easy to use.</p>
      <p class="subsq">We cover more on this topic in <a class="content-external-link" href="part-005-chapter-024.xhtml">Part V: ”Reliable Systems.”</a></p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Understand</span> the codebase</b></p>
      <p class="subsq"><b>Understand smaller codebases inside out.</b> When working with a decent-sized codebase – typically no larger than 100,000 lines and written by no more than 20 people – there’s no excuse for not understanding <i>exactly</i> where everything is located. Look through the structure of the codebase, read a lot of code, and map out how the different parts of the code are connected.</p>
      <p class="subsq">Draw up architecture diagrams based on reading the code, and ask people on your team to confirm if your understanding is correct. Get to the point where you know which part of the code owns what functionality.</p>
      <p class="subsq"><b>With large codebases, it’s good to understand their structure and how to find relevant parts.</b> At larger companies, codebases are common with well over 1M lines built by hundreds of engineers. It’s unrealistic to understand a codebase of this size deeply, but it is reasonable to aim for a <i>broad</i> understanding so you can go deep into the parts of it you need to work on.</p>
      <p class="subsq">At companies that use monorepos, get a sense of their structure and what different parts of the monorepo are responsible for. How are various parts of the system built? How are tests run?</p>
      <p class="subsq">At companies using standalone repositories, seek access to these. Aim to understand how systems work at a high level relating to your team. It’s a good exercise to check some of these out, build them, run tests, and run the service or feature locally.</p>
      <p class="subsq"><b>Find out how to search the whole codebase, and learn useful shortcuts. </b>Most companies have some kind of “global code search.” This might be a custom, in-house solution, or a vendor like GitHub’s code search, or Sourcegraph. Find out how to use the global code search tool and which features it supports. For example, how can you search a specific folder of the code? How can you search for test cases? What about searching only the codebase that your team owns?</p>
      <p class="subsq">Even at large companies where engineers can access most of the codebase, some parts of the codebase may be off-limits. This is often for compliance, regulatory, or confidentiality reasons. In most cases, it should make no real difference to your day-to-day work. But if it slows you down, you could ask for access.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Know enough</span> about the infrastructure</b></p>
      <p class="subsq">Some production issues are caused by infrastructure problems. Figure out how services are deployed into production, how secrets are stored, and how certificates are set up. Look into how the infrastructure is managed, and where infrastructure configurations are stored.</p>
      <p class="subsq">If you work at a company with a dedicated infrastructure team, it can be tempting to skip the learning process and turn to the infra team, when you suspect an infrastructure issue. However, this approach will ultimately slow you down. Besides, learning how infrastructure works under the hood is not only interesting in itself; this depth of understanding is table stakes for well-rounded senior engineers.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Learn</span> through outages</b></p>
      <p class="subsq">Debug outages as they happen and reread old outage investigations. A great way to improve your debugging skills is to debug when it <i>really</i> matters, as outages happen. If your team has an outage, offer to help investigate and find what caused it so that the cause can be mitigated.</p>
      <p class="subsq">Debugging outages requires learning to access and analyze production logs, locating the code responsible for certain business logic, making changes to the code, validating changes, and rolling them out. All of this happens in urgent situations when timely action matters.</p>
      <p class="subsq">There are ways to improve debugging skills for outages other than waiting for a bug to strike your system. Check out postmortems of former outages, if your company publishes them. As you read, try to “debug” by locating the logs which pinpoint issues, and finding the code behind the outage. Researching historical outages is a great way to learn about new dashboards and systems you don’t know well, and to discover new outage mitigation steps.</p>
      <h2 id="subhead-3" class="section-title subhead keep-with-next paragraph-follows case-upper">3. TECH DEBT</h2>
      <p class="first first-after-subhead">“Tech debt” is a term that experienced software engineers are all too familiar with. It describes the incremental cost of software development on systems over time. Tech debt is what happens when code builds up and makes things more complex.</p>
      <p class="subsq">The characteristics of tech debt are similar to taking on a loan. Used smartly, debt can accelerate progress. But when used poorly, it can become expensive to maintain. And bankruptcy via tech debt is real: it is the point at which it’s cheaper to delete and rewrite an entire codebase than to continue maintaining and fixing it.</p>
      <p class="subsq">Here are typical phases of the relationship between tech debt and software engineers/engineering organizations:</p>
      <ul>
        <li>Unawareness. When a software engineer starts to build software, there’s a period – usually short – when they’re not aware that tech debt exists.</li>
        <li>Denial. As an early-career engineer, it’s easy to assume you could never be the cause of tech debt, or that tech debt which you notice is not a big deal, and so it won’t hurt to ignore it.</li>
        <li>Acceptance. Soon enough, most engineers realize that writing code and introducing tech debt often go hand in hand, especially when there’s insufficient time to do things “properly.” The better a company’s engineering culture, the better engineers and engineering leaders are at acknowledging tech debt.</li>
      </ul>
      <p class="subsq">While tech debt is a given, it accumulates much slower when certain healthy engineering practices are followed for maintainability and ease of code modification. Such practices include writing readable code, testing, code reviews, CI/CD, documentation, sane architecture decisions, and more.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Paying</span> down tech debt</b></p>
      <p class="subsq">With small tech debt, just fix it as you go. Follow the scouting rule of leaving a place – in this case, a codebase instead of a campsite – cleaner than you found it.</p>
      <p class="subsq">For larger pieces of tech debt, take an inventory and quantify the impact it makes and the effort needed to remove it. When there’s lots of tech debt, you won’t be able to tackle it all.</p>
      <p class="subsq">Without data about larger pieces of tech debt, it’s hard to make good decisions on how to deal with it. If it includes things that would take weeks or months to fix, a team must prioritize. How does the value of paying off tech debt compare to doing work with a business-facing impact?</p>
      <p class="subsq"><b>To tackle tech debt purposefully, propose projects with clear impacts. </b>Are there pieces of tech debt begging to be resolved because their impact is so obvious? Reliability, cost savings, faster development cycles, and fewer bugs, are common types of impact I’ve seen people cite in pitches to remove larger tech debt, or get migration projects done.</p>
      <p class="subsq">For example, take duplication of logic as a form of tech debt, with parts of the code copy-pasted to different places. What would be the impact of moving duplicated code to a shared library, and at what cost? The impact will be far greater on a codebase that’s frequently used. On the other hand, a soon-to-be deprecated codebase might mean a large effort for small reward.</p>
      <p class="subsq">Or take the example of slow build times. If a build is run frequently by many engineers, then the impact of paying off tech debt could be large. Just multiply the time wasted per build by the number of times an engineer runs this build per day, times the number of engineers doing this.</p>
      <p class="subsq"><b>Couple tech debt removal with high-impact projects. </b>Here’s the secret of being an engineer who’s seen as productive, and who also removes tech debt: not asking permission. Instead of seeking approval to remove tech debt, productive engineers just bundle tech debt removal with a high-impact project and remove it as part of that project.</p>
      <p class="subsq">The highest priority projects are usually ambitious, with high visibility. And to ship them, systems with the most tech debt are frequently touched. If you need to touch a system that is heavy with tech debt, it means your work will be slower. Therefore, if you’re spending time making changes to systems laden with tech debt, it’s sensible to make the case for reducing tech debt while you’re at it.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Reduce</span> tech debt accumulation</b></p>
      <p class="subsq">Instead of spending time and energy on paying down tech debt, it’s sensible to spend much less time and energy in preventing – or slowing – the accumulation of tech debt in the first place. Here are some practices for this:</p>
      <ul>
        <li><b>Write code that’s easy to read. </b>Code which is easier to read is easier to understand. If understandable code is the target, it’s less likely engineers who touch it later will add “hacks” to work around parts they don’t understand.</li>
        <li><b>Make time to clean up the code.</b> Some tech debt makes its way into code because redundant things are not cleaned up. Remove concluded experiments, unused feature flags, code paths no longer executed, and unfinished code additions.</li>
        <li><b>Build systems with extensibility in mind.</b> A lot of tech debt is introduced when a system needs to be extended – like adding a new use case – but when there’s little time for this. Try to cater for future use cases when building the system and create obvious ways to extend your solution. This is where using well-understood design patterns like the Strategy pattern, Decorator pattern, or Factory pattern is helpful, as well as things like configuration files to specify behavior.</li>
        <li><b>Note tech debt and don’t seek permission to remove small pieces.</b> As you work in the codebase, you’ll notice things that slow you down. Make a note, and tackle them when you have time.</li>
      </ul>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">“Just enough”</span> tech debt</b></p>
      <p class="subsq">Is there such a thing as too little tech debt? If you pay off enough tech debt, you will at some point realize that yes, there is. It goes by the name of “premature optimization” – and can slow down teams and companies at critical times.</p>
      <p class="subsq">Take the example of a startup. Upon launch, speed and fast iteration are key to survival and winning. At this time, do you worry about clean APIs and nice data models, or just dump everything in an unstructured JSON, which any developer can modify? The startups I’ve worked at which grew to be successful, all had a tech debt-heavy approach during the early days.</p>
      <p class="subsq">Ride-sharing app Uber was one such startup. When I joined, there was a lot of leftover, early tech debt, and short-term decisions haunted parts of the codebase. But that tech debt served its purpose, as it allowed Uber to move fast when speed mattered most in getting a product-market fit. Afterward, Uber invested in cleaning it up.</p>
      <p class="subsq">Tech debt is something you want to have in early-stage projects, for throwaway prototypes, minimum viable products (MVPs), and when validating a startup’s business model. Tech debt can be fixed by throwing time and developers at it later like Uber did. Most late-stage startups that are growing fast are usually busy paying off early tech debt on the side – because by this later stage, these startups usually have more people – and time! – to address this issue. Likewise, if a team that owns a mature product is not keeping tech debt in check by investing here and there in keeping it at bay, then something is also probably off.</p>
      <p class="subsq">Pragmatic engineers don’t see tech debt as a bad thing; they see it as a tradeoff between speed and quality. They see it as the characteristic of a system. They put tech debt in the context of a project’s goals and don’t try to pay off more than needed. They also keep track of the debt and step in to reduce it before it mounts up – and being creative where needed.</p>
      <h2 id="subhead-4" class="section-title subhead keep-with-next paragraph-follows case-upper">4. DOCUMENTATION</h2>
      <p class="first first-after-subhead">“Documentation” can refer to a few areas, and not all types of documentation are relevant for every project. Here’s a list of common types of documentation which engineers write, and when it’s helpful to write and maintain them.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Design documents/request</span> for comment documents</b></p>
      <p class="subsq">These provide a high-level view of a system. They might contain diagrams and the reasoning behind technology choices and tradeoffs.</p>
      <p class="subsq">Design documents have the most value when written before coding starts, and when circulated for feedback, as the goals of these documents are to help build the right thing, and to surface misunderstandings early.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Test plans,</span> rollout plans, migration plans</b></p>
      <p class="subsq">When project planning is complete, there are documents which help ensure the system will be of high quality, such as:</p>
      <ul>
        <li><b>Test plan</b>: how will the system be tested? Which edge cases are essential to exercise? Will these tests be one-off, manual, or automated? If there is a list of manual tests – often called “sanity tests” – then the list will need to be kept updated.</li>
        <li><b>Rollout plan</b>: how will the system be rolled out? Which feature flags will be used, how will the experiment run, and to which regions or user cohorts will it roll out? This document usually needs input from product or data science folks.</li>
        <li><b>Migration plan</b>: when migrating from one system to another, what is the approach? How will it be validated that the new system works correctly before traffic is moved to it? What are the phases of the migration?</li>
      </ul>
      <p class="subsq">There’s plenty of value in writing these documents at the start of a project. There’s usually little value in maintaining them once the project has been rolled out, or a migration finished.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Interface and integration</span> documentation</b></p>
      <p class="subsq"><b>API or interface documentation. </b>When developing an API or interface for use by other software engineers, this documentation explains things like:</p>
      <ul>
        <li>HowtousetheAPI</li>
        <li>The list of endpoints, the input each one expects, expected outputs</li>
        <li>Error codes and messages returned</li>
        <li>Code sample on using the API</li>
      </ul>
      <p class="subsq">API documentation is something you’ll want to keep up to date when changing parts of the code. Explore ways to do this automatically – for example, generating the documentation using comments.</p>
      <p class="subsq">SDK (software development kit) documentation and integration or plugin documentation, is similar to API documentation, as these guides help other teams use your SDK, integration, or plugins.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Release notes</span></b></p>
      <p class="subsq">Some engineering teams still compile release notes for each major release – even though this practice seems to have gotten out of fashion across most of the industry these days. Writing release notes is usually straightforward, and doesn’t take long. Just summarize which customers will notice the impact of your work, or collate the impacts of all features shipped. This can make it much easier to update API, SDK and integration documentation.</p>
      <p class="subsq">Release notes offer a great way to reflect on the work. They’re also an excellent reference to share with stakeholders such as other engineering teams, or even non-technical teams.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Onboarding documentation</span></b></p>
      <p class="subsq">How can new engineers learn how a system works which your team owns? The answer is good onboarding documentation, which includes:</p>
      <ul>
        <li>A high-level overview of how the system fits into the bigger picture: its responsibility, other systems it interacts with, etc.</li>
        <li>How to modify the system: checking code, how to make changes.</li>
        <li>How to test and validate changes by running tests, or inspecting certain parts.</li>
        <li>How to deploy it to production, deployments which might be automatic via CI/CD.</li>
        <li>How to monitor the production system.</li>
        <li>How alerting works and how to tweak it, if needed.</li>
        <li>Tips on how to debug the system in case of production incidents.</li>
      </ul>
      <p class="subsq">Onboarding documentation is very valuable for new joiners, and sometimes for existing team members, too! Unfortunately, there’s usually little incentive to write or maintain it, especially if no new engineer is joining the team.</p>
      <p class="subsq">I suggest investing in putting this documentation together, for when a new colleague joins, and updating it for each new joiner. Why not ask the new recruit to edit the documentation, fix incorrect details, and add missing parts, as a task near the end of their onboarding?</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">A team “handbook”</span></b></p>
      <p class="subsq">How does the team operate? How does the team’s mission tie into business objectives? A team handbook answers these questions and also covers areas like:</p>
      <ul>
        <li>How work gets prioritized</li>
        <li>How team members go about raising issues, and picking up the next thing to work on</li>
        <li>Processes the team uses</li>
        <li>Team values</li>
      </ul>
      <p class="subsq">If your team does not yet have a handbook, talk with the lead or manager, and suggest putting one together. If you have enough trust with the team, you could simply start such a handbook, and ask others for input.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Oncall runbook documentation</span></b></p>
      <p class="subsq">What are the steps to take when the oncall engineer is paged with an alert from a system? Where can they find relevant dashboards and logs? Which dependencies does this system have on other systems? Good oncall runbooks answer these questions.</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">User manuals</span> and guides</b></p>
      <p class="subsq">If the software you build has end users working with it, then they need manuals that explain how it works. They will need different programming languages to describe the system, while screenshots and visual cues will be very useful.</p>
      <p class="subsq">Even if these guides already exist, ensure to flag when you change parts of the system that change its behavior for users. If possible, update the user guide personally; after all, you made the change and understand it best!</p>
      <p class="implicit-break"></p>
      <p class="first first-in-section first-full-width"><b><span class="first-phrase">Documentation is</span> a high-leverage activity</b></p>
      <p class="subsq">Writing documentation can be time-consuming at first, but it’s a very high-leverage activity. Also, once a document is written, keeping it up to date is more straightforward. Good documentation, such as for onboarding, can help greatly reduce tech debt by providing education on how systems work.</p>
      <h2 id="subhead-5" class="section-title subhead keep-with-next paragraph-follows case-upper">5. SCALING BEST PRACTICES ACROSS THE TEAM</h2>
      <p class="first first-after-subhead">As a senior engineer, strive to deliver quality work and help your team do the same. An obvious way to do this is with best practices.</p>
      <p class="subsq">What is a “best practice?” It’s a proven engineering approach which is very effective in the environment you work in. Individuals and teams following best practices usually get things done quicker, with fewer defects, and produce more easily maintainable code.</p>
      <p class="subsq">However, the term can be misleading as each team and company is different in its skillsets and dynamics. A practice which works very nicely for one team might be less efficient for another.</p>
      <p class="subsq"><b>“Software engineering practices”</b> is a term I suggest as an alternative to “best practices.” Tried-and-tested software engineering practices have applications for several parts of the software engineering process, such as:</p>
      <ul>
        <li><b>A written planning process. </b>Before starting to code non-trivial projects, a plan is written and circulated for feedback. This plan could be a Request for Comment (RFC,) an Engineering Requirements Document (EDD,) a Design Doc, or an Architectural Decision Record (ADR.)</li>
        <li><b>Automated testing.</b> The writing of unit, integration, end-to-end, performance, load, or other types of tests. This approach usually increases quality and maintainability, often resulting in quicker shipping of software by flagging regressions more rapidly. <i>We cover more on testing in the next chapter.</i></li>
        <li><b>Test-driven development. </b>A subset of automated testing where tests are written before the code is.</li>
        <li><b>Code reviews.</b> Other engineers review and sign off code before it’s committed.</li>
        <li><b>Post-commit code reviews. </b>Code reviews are done after commits are made. This approach typically increases iteration speed, while keeping some code reviews in place. A tradeoff is that more regressions can make their way to production. This practice works best with very small or highly experienced teams.</li>
        <li><b>Testing environments.</b> Shipping code to intermediary environments for further testing, not straight to production. The upside is higher confidence that the code is correct. The downside is it takes longer to ship things to production and maintaining testing environments is more work.</li>
        <li><b>Staged rollouts. </b>Releasing new features in stages and then gathering feedback, instead of releasing them to customers all at once. Feature flags, experimentation, and A/B testing are all tools for staged rollouts. <i>We cover more details on these in <a class="content-external-link" href="part-004-chapter-017.xhtml">Part IV: ”Shipping to Production.”</a></i></li>
        <li><b>Testing in production safely. </b>Shipping to production, instead of using testing environments and employing safe methods of testing, utilizing things like tenancies, feature flags or staged rollouts.</li>
      </ul>
      <p class="subsq">Which practices should you put in place for your team? Actually, this is the wrong question to start with. Instead, ask what the biggest challenges are to shipping things on your team.</p>
      <p class="subsq">Is the challenge that too many bugs make it to production? Consider whether practices like TDD, testing environments, or testing in production, would help. Is it that code reviews take a long time? Consider whether a practice could help with this: for example, dedicating time for reviews, fewer reviews, smaller code changes, or something else.</p>
      <p class="subsq">The more familiar you are with engineering practices, the more you can recognize when a specific practice can help your team. One way to get familiar is by learning them. Another way is to get input from people with first-hand experience. The most educational way of all is to acquire personal experience by trying them out!</p>
    </div>
    <div class="fewer-than-100-notes">
      <div class="endnotes">
        <div class="endnotes-separator">
        </div>
        <div>
          <div id="part-3-chapter-3-endnote-1-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-013.xhtml#part-3-chapter-3-endnote-1">1</a> </span><a class="content-external-link text-is-url" href="https://reactivex.io">https://reactivex.io</a></p>
          </div>
          <div id="part-3-chapter-3-endnote-2-text" class="endnote-text"><p class="first"><span class="endnote-text-number"><a class="endnote-backlink" href="part-003-chapter-013.xhtml#part-3-chapter-3-endnote-2">2</a> </span><a class="content-external-link text-is-url" href="https://reactivex.io/languages.html">https://reactivex.io/languages.html</a></p>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
